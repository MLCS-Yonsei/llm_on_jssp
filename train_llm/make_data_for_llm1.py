## 프롬프트 생성 조합은 4개씩만 남기고 최대한 종류끼리는 안겹치게, 같은 종류 내에서는 비슷하게 ##
# 샘플간 job, machine, operation, duration 랜덤 #
# 하나의 샘플 내에서 operation 개수 랜덤 (고정X)
# 하나의 job 내에서 machine 중복 허용X (1번 썼다가 2번 쓴 후에 다시 1번 쓰는 경우 제외)
# 평가기준(fastest, best_makespan) 랜덤

import random
import json

machine_expr = [
    "M{idx}",
    "Machine {idx}",
    "machine number {idx}",
    "the {idx}th machine"
]
job_expr = [
    "Job {idx}",
    "J{idx}",
    "Task {idx}",
    "Operation {idx}"
]
time_expr = [
    "for {dur}",
    "takes {dur} time",
    "for {dur} time units",
    "during {dur} units"
]
op_sep = [
    ", ",
    "; ",
    " then ",
    " and then "
]
job_joiner = [
    "\n",
    " ",
    ". ",
    "; "
]
step_intro = [
    "",
    "First, ",
    "To start, ",
    "Initially, "
]
cont_intro = [
    "next ",
    "after that ",
    "subsequently ",
    "and then ",
    ""
]

criteria_expr = [
    ("fastest", "Choose the solution generated by the solver that completed its computation the fastest among all solvers."),
    ("best_makespan", "Choose the solution generated by the solver that achieved the shortest makespan among all given solvers.")
]

def gen_job_op(machine_pool, min_ops=2, max_ops=5):
    max_ops = min(max_ops, len(machine_pool))
    ops_per_job = random.randint(min_ops, max_ops)
    machines = random.sample(machine_pool, ops_per_job)
    durs = [random.randint(1, 9) for _ in range(ops_per_job)]
    op_strs = []
    for i, (m, d) in enumerate(zip(machines, durs)):
        m_expr = random.choice(machine_expr).format(idx=m+1)
        t_expr = random.choice(time_expr).format(dur=d)
        if i == 0:
            intro = random.choice(step_intro)
        else:
            intro = random.choice(cont_intro)
        op_strs.append(f"{intro}{m_expr} {t_expr}")
    op_sentence = random.choice(op_sep).join(op_strs)
    return op_sentence, machines, durs

def gen_job_line(idx, machine_pool, min_ops=2, max_ops=5):
    job_name = random.choice(job_expr).format(idx=idx+1)
    op_sentence, machines, durs = gen_job_op(machine_pool, min_ops, max_ops)
    if random.random() < 0.3:
        job_line = f"{job_name} has {len(machines)} operations: {op_sentence}"
    elif random.random() < 0.6:
        job_line = f"{job_name}: {op_sentence}"
    else:
        job_line = f"{job_name} consists of {op_sentence}"
    return job_line, machines, durs

def generate_dataset(n_samples=200,
                    min_jobs=2, max_jobs=5,
                    min_machines=3, max_machines=7,
                    min_ops=2, max_ops=5):
    all_samples = []
    for _ in range(n_samples):
        num_jobs = random.randint(min_jobs, max_jobs)
        num_machines = random.randint(min_machines, max_machines)
        machine_pool = list(range(num_machines))
        jobs = []
        matrix = []
        for j in range(num_jobs):
            line, machines, durs = gen_job_line(j, machine_pool, min_ops, max_ops)
            jobs.append(line)
            row = [[m, d] for m, d in zip(machines, durs)]
            matrix.append(row)

        # 평가 기준
        criteria, criteria_prompt = random.choice(criteria_expr)

        # 🔵 instruction, input, output 구조화!
        instruction = (
            "Convert the following job description into a matrix. "
            "Each row is a job. Each tuple is (machine_index, duration). "
            "Also, return the correct label based on the evaluation criterion. "
            "Output must be in JSON format with keys 'matrix' and 'label'."
        )
        input_text = (
            f"Evaluation criterion: {criteria_prompt}\n\n"
            "Job descriptions:\n"
            + "\n".join(jobs)
        )
        output_text = json.dumps({
            "matrix": matrix,
            "label": criteria
        })

        sample = {
            "instruction": instruction,
            "input": input_text,
            "output": output_text
        }
        all_samples.append(sample)
    return all_samples

# 생성 예시
samples = generate_dataset(n_samples=100)

path = "C:/Users/djm06/Desktop/MLP/team_project/"
#path = "./medical/jssp_llm/"
with open(path + "train_llm/dataset_llm1_100_new_new.jsonl", "w", encoding="utf-8") as f:
    for ex in samples:
        f.write(json.dumps(ex) + "\n")

print(f"Sample example:\n{samples[0]}")
print("dataset_llm1_5k.jsonl file created.")






'''
필요없어서 지금은 matrix만 출력
{"processing_times": [
    [4, 2, 9, 6, 6],    // Job 1의 각 작업(oper.) 소요 시간
    [5, 6, 6, 9, 8],    // Job 2의 각 작업 소요 시간
    [1, 3, 9, 5, 3]     // Job 3의 각 작업 소요 시간
    [7, 3, 9, 5, 3]     // Job 4의 각 작업 소요 시간
 ],
 "machine_ids": [
    [4, 0, 0, 3, 1],    // Job 1의 각 작업이 배정된 machine 번호 (0부터 시작)
    [4, 1, 0, 4, 4],    // Job 2의 각 작업이 배정된 machine 번호
    [1, 2, 4, 3, 2],    // Job 3의 각 작업이 배정된 machine 번호
    [1, 2, 4, 3, 2]     // Job 4의 각 작업이 배정된 machine 번호
 ], 
 "matrix": [
    [[4, 4], [0, 2], [0, 9], [3, 6], [1, 6]],   // Job 1의 각 작업 (machine_index, duration)
    [[4, 5], [1, 6], [0, 6], [4, 9], [4, 8]],   // Job 2의 각 작업
    [[1, 7], [2, 3], [4, 9], [3, 5], [2, 3]]    // Job 3의 각 작업
 ],
 "label": 0
}
'''
